[
  {
    "kind": 1,
    "language": "markdown",
    "value": "# Malloy Indexes\nMalloy has a special query operator that builds dimensional search indexes for sources.  Search indexes are generally used by Malloy Composer (Malloy's BI interface), but can also be used for other things.\n\nWhen filtering data, you might know a term, but not necessarily which column in the one of the join data contains it.  Indexing the data on field names and high cardinality fields let's you qucikly find the term and the associated value.\n\nThough I haven't played with it.  Indexing could be used by LLMs to find the interesting column/term mapping in the data set.\n\n## Simple Example\nWe're going to take the airports table and index it.  Some things to notice.\n\n* The query operator `index:` takes a list of dimensions we would like in our index.  \n* The results of an index are unordered, so we pass the result to another stage to order the results.  \n* In this case, `weight` is the row count of the results returned.  \n* non-string -type fields are represented as ranges across all rows.\n* Click `ShowSQL` to see how this query works in SQL.",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "malloy",
    "value": "query:  table('duckdb:data/airports.parquet') -> {\n  index: *\n} -> {\n  project: *\n  order_by: weight desc\n}",
    "metadata": {}
  },
  {
    "kind": 1,
    "language": "markdown",
    "value": "## Index For filtering queries\n\nIndexes can be used find the best way to filter a dataset.  For example supposed we'd like to find 'SANTA CRUZ' in the dataset, but we don't quite know how to filter for it.  In a UI you might imagine that you type 'SANTA' and let have suggestons for values that might be appropriate.  In the top results we can see that 'SANTA CRUZ' is both a `city` and a `county`..",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "malloy",
    "value": "query:  table('duckdb:data/airports.parquet') -> {\n  index: *\n} -> {\n  where: fieldValue ~ r'SANTA'\n  project: *\n  order_by: weight desc\n  limit: 15\n}",
    "metadata": {}
  },
  {
    "kind": 1,
    "language": "markdown",
    "value": "We can then write a simple query to show the rows.  It turns out that 'SANTA CRUZ' is a county in both California and Arizona.",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "malloy",
    "value": "query:  table('duckdb:data/airports.parquet') -> {\n  where: county ~ 'SANTA CRUZ'\n  project: *\n}",
    "metadata": {}
  },
  {
    "kind": 1,
    "language": "markdown",
    "value": "## Indexing to show top values\nIt is often difficult to approach a new dataset.  The index operator provides an intersting way to quickly gain an understanding of the dataset.  By piping the results of an index another stage, we can quickly see all the interesting values for each of the interesting dimesions.  Again, the weight shows the number of rows for that particular dimension/value.",
    "metadata": {}
  },
  {
    "kind": 2,
    "language": "malloy",
    "value": "query:  table('duckdb:data/airports.parquet') -> {\n  index: *\n} -> {\n  group_by: fieldName\n  nest: values is {\n    group_by: fieldValue, weight\n    order_by: weight desc\n    limit: 10\n  }\n  order_by: fieldName\n}",
    "metadata": {}
  }
]